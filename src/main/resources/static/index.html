<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç‚’å¸å—ï¼Ÿ</title>
    <script src="https://unpkg.com/vue@3"></script>
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            background: #0f172a;
            color: #e5e7eb;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        }

        /* ===== ä¸»å¸ƒå±€ ===== */
        #app {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        .left {
            width: 320px;
            background: #020617;
            border-right: 1px solid #1e293b;
            padding: 12px;
            overflow-y: auto;
        }

        .right {
            flex: 1;
            position: relative;
        }

        /* ===== å·¦ä¾§é€šç”¨ ===== */
        .left h1 {
            margin: 0 0 16px;
            text-align: center;
            font-size: 16px;
            color: #cbd5f5;
        }

        .card {
            background: rgba(2, 6, 23, 0.85);
            border: 1px solid #1e293b;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 12px;
        }

        .card h3 {
            margin: 0 0 10px;
            font-size: 13px;
            border-bottom: 1px solid #1e293b;
            padding-bottom: 6px;
            color: #cbd5f5;
        }

        /* ===== è¡¨å• ===== */
        label {
            display: flex;
            flex-direction: column;
            gap: 4px;
            font-size: 12px;
            margin-bottom: 10px;
            color: #94a3b8;
        }

        input {
            background: #0f172a;
            border: 1px solid #1e293b;
            color: #e5e7eb;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        /* ===== æŒ‰é’® ===== */
        button {
            background: #334155;
            border: none;
            color: #e5e7eb;
            font-size: 12px;
            padding: 6px;
            border-radius: 4px;
            cursor: pointer;
        }

        button:hover {
            background: #475569;
        }

        button.active {
            outline: 1px solid #3b82f6;
        }

        /* ===== å›¾è¡¨ & è¦†ç›–å±‚ ===== */
        .right>div:first-child,
        .right svg {
            position: absolute;
            inset: 0;
        }

        .right svg {
            z-index: 20;
        }

        .right>div:last-child {
            position: absolute;
            z-index: 30;
            min-width: 180px;
            background: #020617;
            border: 1px solid #1e293b;
            border-radius: 6px;
            padding: 8px;
            font-size: 12px;
            pointer-events: none;
        }

        .right>div:last-child>div>div {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }
    </style>
</head>

<body>
    <div id="app">
        <!-- å·¦ä¾§é¢æ¿ -->
        <div class="left">
            <h1>å¸å®‰æ°¸ç»­åˆçº¦</h1>

            <div class="card">
                <h3>ç»˜å›¾å·¥å…·</h3>
                <label>åŸºç¡€å·¥å…·</label>
                <div style="display: flex;flex-direction: row;gap: 4px;">
                    <button :class="{active: activeTool==='cursor'}" @click="setTool('cursor')">æŸ¥çœ‹Kçº¿</button>
                    <button style="color: red" @click="clearAllOverlays">æ¸…é™¤å›¾å½¢</button>
                </div>
                <label>çº¿æ®µå·¥å…·</label>
                <div style="display: flex;flex-direction: row;gap: 4px;">
                    <button :class="{active: activeTool==='trendline'}" @click="setTool('trendline')">è¶‹åŠ¿çº¿</button>
                    <button :class="{active: activeTool==='rr'}" @click="setTool('rr')">ç›ˆäºæ¯”</button>
                    <button :class="{active: activeTool==='mm'}" @click="setTool('mm')">MM</button>
                </div>
                <label>çŸ©å½¢å·¥å…·</label>
                <div style="display: flex;flex-direction: row;gap: 4px;">
                    <button :class="{active: activeTool==='rect'}" @click="setTool('rect')">çŸ©å½¢</button>
                    <button :class="{active: activeRectColor==='#a7eec0'}" style="color: #a7eec0" @click="activeRectColor = '#a7eec0'">ç»¿è‰²</button>
                    <button :class="{active: activeRectColor==='#f46060'}"  style="color: #f46060" @click="activeRectColor = '#f46060'">çº¢è‰²</button>
                    <button :class="{active: activeRectColor==='#efd763'}"  style="color: #efd763" @click="activeRectColor = '#efd763'">æ©™è‰²</button>
                </div>
            </div>
<!--            <div class="card">-->
<!--                <h3>åˆçº¦æ¨¡æ‹Ÿå™¨</h3>-->
<!--                <div style="display: flex;flex-direction: row;gap: 4px;">-->
<!--                    &lt;!&ndash; æ•°é‡ &ndash;&gt;-->
<!--                    <div>-->
<!--                        <label>æ•°é‡</label>-->
<!--                        <input type="number" step="0.0001" style="width: 80px" v-model.number="simQty"-->
<!--                            @input="this.calcContractSim">-->
<!--                    </div>-->
<!--                    &lt;!&ndash; æ æ† &ndash;&gt;-->
<!--                    <div>-->
<!--                        <label>æ æ†</label>-->
<!--                        <input type="number" min="1" max="100" style="width: 80px" v-model.number="simLeverage"-->
<!--                            @input="this.calcContractSim">-->
<!--                    </div>-->
<!--                    <div>-->
<!--                        <label>å¼€ä»“ä»·</label>-->
<!--                        <input type="number" v-model.number="simEntryPrice" style="width: 80px"-->
<!--                            @input="this.calcContractSim" placeholder="ç‚¹å‡»å›¾è¡¨è‡ªåŠ¨å¡«å……æˆ–æ‰‹åŠ¨è¾“å…¥">-->
<!--                    </div>-->
<!--                </div>-->
<!--                &lt;!&ndash; æ–¹å‘ &ndash;&gt;-->
<!--                <div style="display: flex;flex-direction: row;gap: 4px;">-->
<!--                    <button @click="this.positionSide = 'long';this.calcContractSim" style="color: green">å¼€å¤š</button>-->
<!--                    <button @click="this.positionSide = 'short';this.calcContractSim" style="color: red">å¼€ç©º</button>-->
<!--                </div>-->
<!--            </div>-->
            <div class="card">
                <h3>ä»·æ ¼çº¿ç®¡ç†</h3>
                <!-- æ·»åŠ ä»·æ ¼çº¿è¡¨å• -->
                <label>ä»·æ ¼çº¿
                    <input type="text" v-model="newPriceLine.title" placeholder="ä¾‹å¦‚ï¼šå‹åŠ›ä½ã€æ”¯æ’‘ä½">
                    <input type="number" step="0.1" v-model="newPriceLine.price" placeholder="ç‚¹å‡»å›¾è¡¨è‡ªåŠ¨å¡«å……æˆ–æ‰‹åŠ¨è¾“å…¥">
                    <input type="color" v-model="newPriceLine.color" value="#a7eec0">
                </label>
                <button @click="this.addPriceLine">æ·»åŠ ä»·æ ¼çº¿</button>

                <!-- å·²æ·»åŠ ä»·æ ¼çº¿åˆ—è¡¨ -->
                <div style="margin-top: 12px; max-height: 200px; overflow-y: auto;">
                    <div v-for="(line, index) in priceLines" :key="index"
                        style="display: flex; gap: 4px; margin-bottom: 6px; align-items: center; padding: 4px; border: 1px solid #1e293b; border-radius: 4px;">
                        <div style="flex: 1;">
                            <div style="font-size: 11px; color: #94a3b8;">{{ line.title }}</div>
                            <div style="font-size: 11px;">{{ line.price }} <span :style="{color: line.color}">â– </span>
                            </div>
                        </div>
                        <div style="display: flex; gap: 2px;">
                            <button @click="this.togglePriceLineVisible(index)" :title="line.visible ? 'éšè—' : 'æ˜¾ç¤º'">
                                {{ line.visible ? 'éšè—' : 'æ˜¾ç¤º' }}
                            </button>
                            <button @click="this.editPriceLine(index)">ç¼–è¾‘</button>
                            <button @click="this.deletePriceLine(index)" style="background: #ef4444;">åˆ é™¤</button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="card">
                <h3>Kçº¿åŠ è½½</h3>
                <div style="display: flex;flex-direction: column;">
                    <label>æ ‡çš„
                        <select v-model="symbol">
                            <option value="BTCUSDT">BTCUSDT</option>
                            <option value="ETHUSDT">ETHUSDT</option>
                            <option value="XAUUSDT">XAUUSDT</option>
                        </select>
                    </label>
                    <label>ç›˜é¢
                        <select v-model="location">
                            <option value="utc8">å¸¸è§„UTC+8</option>
                            <option value="et">ç¾ä¸œ9:30~16:10</option>
                        </select>
                    </label>
                    <label>èµ·å§‹æ—¶é—´
                        <input type="datetime-local" v-model="startTime">
                    </label>
                    <label>ç»“æŸæ—¶é—´
                        <input type="datetime-local" v-model="endTime">
                    </label>
                    <label>æ—¶é—´å‘¨æœŸ
                        <select v-model="interval">
                            <option value="5m">5m</option>
                            <option value="1h">1h</option>
                        </select>
                    </label>
                    <div style="display: flex;flex-direction: row;gap: 2px;">
                        <button @click="loadKlineByDateRange(0, 0)">åŠ è½½æ•°æ®</button>
                        <button @click="reDownloadKlineByDateRange()">åˆ·æ–°æ•°æ®</button>
                    </div>
                </div>
                <br>
                <div style="display: flex;flex-direction: row;gap: 2px;">
                    <button @click="loadKlineByDateRange(-1, -1)">èµ·å§‹å‰ç§»</button>
                    <button @click="loadKlineByDateRange(-1, 1)">èµ·å§‹åç§»</button>
                    <button @click="loadKlineByDateRange(1, -1)">ç»“æŸå‰ç§»</button>
                    <button @click="loadKlineByDateRange(1, 1)">ç»“æŸåç§»</button>
                </div>
            </div>

        </div>

        <!-- å³ä¾§å›¾è¡¨ -->
        <div class="right" ref="chartWrapper">
            <!-- å›¾è¡¨å®¹å™¨ -->
            <div ref="chartEl"></div>

            <!-- SVG Overlay -->
            <svg ref="overlayEl" :style="{pointerEvents: activeTool==='cursor'?'none':'auto'}"
                @pointerdown="onOverlayPointerDown" @pointermove="onOverlayPointerMove" @pointerup="onOverlayPointerUp">
            </svg>

            <!-- Tooltip -->
            <div ref="tooltipEl"
                :style="{top: tooltipPos.top+'px', left: tooltipPos.left+'px', opacity: tooltipPos.opacity}">
                <div v-if="currentKline">
                    <div><span>æ—¶é—´(UTC+8)</span><b>{{ formatTimestamp(currentKline["openTime"]) }}</b></div>
                    <div><span>å¼€ç›˜</span><b>{{ currentKline["openPrice"] }}</b></div>
                    <div><span>æœ€é«˜</span><b>{{ currentKline["highPrice"] }}</b></div>
                    <div><span>æœ€ä½</span><b>{{ currentKline["lowPrice"] }}</b></div>
                    <div>
                        <span>æ”¶ç›˜</span>
                        <b
                            :style='{color: currentKline["closePrice"] >= currentKline["openPrice"] ? "#22c55e" : "#ef4444"}'>
                            {{ currentKline["closePrice"] }}
                        </b>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const STORAGE_KEY = 'BTCUSDT_5M_KLINE_TIME_RANGE';
        const { createApp } = Vue

        createApp({
            data() {
                return {
                    // å›¾è¡¨æ ¸å¿ƒå®ä¾‹
                    chart: null,
                    candleSeries: null,

                    symbol: 'BTCUSDT',

                    // æ—¥æœŸ
                    startTime: '2025-01-01T00:00',
                    endTime: '2025-01-01T12:00',
                    interval: '5m',
                    location: 'utc8',

                    // ä¸šåŠ¡æ•°æ®
                    step: 5,
                    isLoading: false,      // åŠ è½½çŠ¶æ€
                    operateMsg: '',        // æ“ä½œæç¤ºä¿¡æ¯
                    operateSuccess: false, // æ“ä½œæ˜¯å¦æˆåŠŸ
                    currentKlineData: [],  // å½“å‰Kçº¿æ•°æ®
                    currentKline: null,    // æ‚¬æµ®çš„å½“å‰Kçº¿
                    tooltipPos: {          // æ‚¬æµ®æç¤ºä½ç½®
                        top: 0,
                        left: 0,
                        opacity: 0
                    },

                    // ç»˜å›¾ç›¸å…³
                    overlayDragging: false,
                    overlayTempPoint: null,
                    trendLines: [],        // è¶‹åŠ¿çº¿æ•°æ®
                    activeTool: 'cursor',  // cursor | trendline | rect | rr
                    rects: [],             // çŸ©å½¢æ•°æ®
                    activeRectColor: '#a7eec0',
                    rectTemp: null,        // ä¸´æ—¶çŸ©å½¢æ•°æ®
                    rrTools: [],           // ç›ˆäºæ¯”å·¥å…·æ•°æ®
                    rrTemp: null,          // ä¸´æ—¶ç›ˆäºæ¯”æ•°æ®
                    mmTools: [],           // Measured Move å·¥å…·æ•°æ®
                    mmTemp: null,          // ä¸´æ—¶Measured Move æ•°æ®
                    currentMouseX: 0,      // å½“å‰é¼ æ ‡Xåæ ‡
                    currentMouseY: 0,      // å½“å‰é¼ æ ‡Yåæ ‡

                    // æŒ‡æ ‡çº¿
                    ema20Series: null,

                    // ä»·æ ¼çº¿ç›¸å…³
                    newPriceLine: { // æ–°å¢ä»·æ ¼çº¿çš„ä¸´æ—¶æ•°æ®
                        title: '',
                        price: '',
                        color: '#a7eec0'
                    },
                    priceLines: [], // å·²æ·»åŠ çš„ä»·æ ¼çº¿åˆ—è¡¨ï¼Œæ¯é¡¹ç»“æ„ï¼š{title, price, color, visible, series}
                    editingPriceLineIndex: -1, // æ­£åœ¨ç¼–è¾‘çš„ä»·æ ¼çº¿ç´¢å¼•ï¼ˆ-1è¡¨ç¤ºæœªç¼–è¾‘ï¼‰

                    // åˆçº¦æ¨¡æ‹Ÿå™¨
                    isSim: false,
                    positionSide: 'long', // long | short
                    // ä¸‹å•æ•°é‡
                    simQty: 0.01,
                    // æ æ†
                    simLeverage: 60,
                    // å¼€ä»“ä»·
                    simEntryPrice: null,
                    // åˆå§‹ä¿è¯é‡‘
                    simMargin: null,
                    // çˆ†ä»“ä»·ï¼ˆå¼ºå¹³ä»·æ ¼ï¼‰
                    simLiqPrice: null,
                    // æŒ‚å•æ‰‹ç»­è´¹ç‡
                    feeMaker: 0.0002,
                    // åƒå•æ‰‹ç»­è´¹ç‡
                    feeTaker: 0.0006,

                    // APIåŸºç¡€åœ°å€
                    apiBaseUrl: 'http://localhost:8765'
                };
            },
            mounted() {
                // === 1. ä»æµè§ˆå™¨ç¼“å­˜ä¸­æ¢å¤æ—¶é—´ ===
                const cache = localStorage.getItem(STORAGE_KEY);
                if (cache) {
                    try {
                        const { startTime, endTime, interval, location, symbol } = JSON.parse(cache);
                        if (startTime) this.startTime = startTime;
                        if (endTime) this.endTime = endTime;
                        if (interval) this.interval = interval;
                        if (location) this.location = location;
                        if (symbol) this.symbol = symbol;
                    } catch (e) {
                        console.warn('æ—¶é—´ç¼“å­˜è§£æå¤±è´¥ï¼Œå·²å¿½ç•¥');
                    }
                }
                // åˆå§‹åŒ–å›¾è¡¨
                this.initChart();
                // åˆå§‹åŒ–åå­—å…‰æ ‡ç›‘å¬
                this.initCrosshairListener();
                // çª—å£å¤§å°ç›‘å¬
                window.addEventListener('resize', this.handleWindowResize);
                // åˆå§‹åŒ–Overlay
                this.initOverlay();
            },
            unmounted() {
                window.removeEventListener('resize', this.handleWindowResize);
                // ç§»é™¤overlayçš„resizeç›‘å¬
                window.removeEventListener('resize', this.resizeOverlay);
                // ç§»é™¤å›¾è¡¨ç›‘å¬
                if (this.chart) {
                    this.chart.timeScale().unsubscribeVisibleTimeRangeChange(this.renderOverlay);
                    this.chart.unsubscribeCrosshairMove(this.renderOverlay);
                }
            },
            watch: {
                startTime: {
                    handler() {
                        this.saveCache();
                    }
                },
                endTime: {
                    handler() {
                        this.saveCache();
                    }
                },
                interval: {
                    handler() {
                        this.saveCache();
                    }
                },
                location: {
                    handler() {
                        this.saveCache();
                    }
                },
                symbol: {
                    handler() {
                        this.saveCache();
                    }
                },
            },
            methods: {
                calcContractSim() { },
                saveCache() {
                    localStorage.setItem(
                        STORAGE_KEY,
                        JSON.stringify({
                            startTime: this.startTime,
                            endTime: this.endTime,
                            interval: this.interval,
                            location: this.location,
                            symbol: this.symbol
                        })
                    );
                },
                /**
                 * è®¾ç½®å½“å‰æ¿€æ´»çš„ç»˜å›¾å·¥å…·
                 */
                setTool(tool) {
                    this.activeTool = tool;

                    document.body.style.cursor =
                        tool === 'cursor' ? 'default' : 'crosshair';

                    this.overlayTempPoint = null;
                    this.rectTemp = null;
                    this.rrTemp = null;
                    this.mmTemp = null;
                },
                /**
                 * åˆå§‹åŒ–å›¾è¡¨
                 */
                initChart() {
                    if (!this.$refs.chartEl) return;

                    // åˆ›å»ºå›¾è¡¨å®ä¾‹
                    this.chart = LightweightCharts.createChart(this.$refs.chartEl, {
                        layout: { background: { color: '#0f0f0f' }, textColor: '#b2b2b2' },
                        grid: { vertLines: { color: '#1c1c1c' }, horzLines: { color: '#1c1c1c' } },
                        timeScale: {
                            timeVisible: true,
                            secondsVisible: false,
                            rightOffset: 30
                        },
                        crosshair: {
                            horzLine: {
                                color: '#999',
                                style: LightweightCharts.LineStyle.Dashed,
                            },
                            vertLine: {
                                visible: true,
                                color: '#666',
                                style: LightweightCharts.LineStyle.Dashed,
                            },
                        },
                        height: this.$refs.chartEl.clientHeight
                    });

                    // åˆ›å»ºKçº¿ç³»åˆ—
                    this.candleSeries = this.chart.addSeries(LightweightCharts.CandlestickSeries, {
                        upColor: '#089981',
                        downColor: '#f23645',
                        borderUpColor: '#089981',
                        borderDownColor: '#f23645',
                        wickUpColor: '#089981',
                        wickDownColor: '#f23645'
                    });

                    // åˆ›å»ºEMA20ç³»åˆ—
                    this.ema20Series = this.chart.addSeries(
                        LightweightCharts.LineSeries,
                        {
                            color: '#ffeb3b', // è“è‰²ï¼Œç•¥æµ…
                            lineWidth: 1,
                        }
                    );
                },
                calculateEMA(data, period = 20) {
                    const k = 2 / (period + 1);
                    let ema = null;

                    return data.map((item, index) => {
                        const close = item.close;
                        if (ema === null) {
                            ema = close; // ç¬¬ä¸€æ ¹
                        } else {
                            ema = close * k + ema * (1 - k);
                        }
                        return {
                            time: item.time,
                            value: Number(ema.toFixed(4))
                        };
                    });
                },
                // æ·»åŠ ä»·æ ¼çº¿
                addPriceLine() {
                    if (!this.newPriceLine.price) {
                        this.showOperateMsg('åç§°å’Œä»·æ ¼ä¸èƒ½ä¸ºç©º', false);
                        return;
                    }
                    // åˆ¤æ–­æ˜¯å¦ä¸ºç¼–è¾‘çŠ¶æ€
                    if (this.editingPriceLineIndex > -1) {
                        const editLine = this.priceLines[this.editingPriceLineIndex];
                        // æ›´æ–°å·²æœ‰ä»·æ ¼çº¿çš„å±æ€§
                        editLine.title = this.newPriceLine.title;
                        editLine.price = this.newPriceLine.price;
                        editLine.color = this.newPriceLine.color;
                        // æ›´æ–°å›¾è¡¨ä¸­çš„ä»·æ ¼çº¿æ ·å¼å’Œæ•°æ®
                        editLine.series.applyOptions({
                            color: editLine.color,
                            // title: editLine.title
                        });
                        this.updatePriceLineData(editLine);
                        this.editingPriceLineIndex = -1;
                        this.showOperateMsg('ä»·æ ¼çº¿ç¼–è¾‘æˆåŠŸ', true);
                    } else {
                        // æ–°å¢ä»·æ ¼çº¿
                        const lineSeries = this.chart.addSeries(LightweightCharts.LineSeries, {
                            color: this.newPriceLine.color,
                            lineWidth: 2,
                            crosshairMarkerVisible: false,
                            // title: this.newPriceLine.title,
                        });
                        // æ„é€ ä»·æ ¼çº¿æ•°æ®ï¼ˆæ¨ªå‘çº¿éœ€è¦ç›¸åŒä»·æ ¼çš„é¦–å°¾æ•°æ®ï¼‰
                        const priceLineData = this.buildPriceLineData(Number(this.newPriceLine.price));
                        lineSeries.setData(priceLineData);

                        this.priceLines.push({
                            // title: this.newPriceLine.title,
                            price: Number(this.newPriceLine.price),
                            color: this.newPriceLine.color,
                            visible: true,
                            series: lineSeries
                        });
                        this.showOperateMsg('ä»·æ ¼çº¿æ·»åŠ æˆåŠŸ', true);
                    }
                    // é‡ç½®æ–°å¢è¡¨å•
                    this.newPriceLine = { title: '', price: '', color: '#a7eec0' };
                },

                // æ„å»ºä»·æ ¼çº¿æ•°æ®ï¼ˆæ¨ªå‘çº¿ï¼‰
                buildPriceLineData(price) {
                    const timeScale = this.chart.timeScale();
                    // æ­£ç¡®è·å–å¯è§†åŒºé—´çš„æ—¶é—´èŒƒå›´ï¼ˆè¿”å› {from: å¼€å§‹æ—¶é—´æˆ³, to: ç»“æŸæ—¶é—´æˆ³}ï¼‰
                    const visibleTimeRange = timeScale.getVisibleRange();
                    if (!visibleTimeRange) return [];

                    // è¿”å›æ¨ªå‘çº¿æ•°æ®ï¼ˆé¦–å°¾ä¸¤ç‚¹ç¡®å®šä¸€æ¡æ¨ªçº¿ï¼‰
                    return [
                        { time: visibleTimeRange.from, value: price },
                        { time: visibleTimeRange.to, value: price }
                    ];
                },

                // æ›´æ–°ä»·æ ¼çº¿æ•°æ®ï¼ˆé€‚é…è§†å›¾å˜åŒ–ï¼‰
                updatePriceLineData(line) {
                    if (!line.visible) return;
                    const priceLineData = this.buildPriceLineData(Number(line.price));
                    line.series.setData(priceLineData);
                },

                // åˆ‡æ¢ä»·æ ¼çº¿æ˜¾ç¤º/éšè—
                togglePriceLineVisible(index) {
                    const line = this.priceLines[index];
                    line.visible = !line.visible;
                    line.series.applyOptions({ visible: line.visible });
                },

                // ç¼–è¾‘ä»·æ ¼çº¿
                editPriceLine(index) {
                    const line = this.priceLines[index];
                    this.newPriceLine = {
                        title: line.title,
                        price: line.price,
                        color: line.color
                    };
                    this.editingPriceLineIndex = index;
                },

                // åˆ é™¤ä»·æ ¼çº¿
                deletePriceLine(index) {
                    const line = this.priceLines[index];
                    // ä»å›¾è¡¨ä¸­ç§»é™¤ç³»åˆ—
                    this.chart.removeSeries(line.series);
                    // ä»åˆ—è¡¨ä¸­åˆ é™¤
                    this.priceLines.splice(index, 1);
                    this.showOperateMsg('ä»·æ ¼çº¿å·²åˆ é™¤', true);
                    this.editingPriceLineIndex = -1;
                },
                /**
                 * åˆå§‹åŒ–Overlay
                 */
                initOverlay() {
                    this.resizeOverlay();
                    // ç¡®ä¿åªç»‘å®šä¸€æ¬¡resizeäº‹ä»¶
                    window.removeEventListener('resize', this.resizeOverlay);
                    window.addEventListener('resize', this.resizeOverlay);

                    // å›¾è¡¨å˜åŒ–æ—¶é‡ç»˜
                    this.chart.timeScale().subscribeVisibleTimeRangeChange(this.renderOverlay);
                    this.chart.subscribeCrosshairMove(this.renderOverlay);
                },
                clearAllOverlays() {
                    this.trendLines = [];
                    this.rects = [];
                    this.rrTools = [];
                    this.mmTools = [];

                    this.overlayTempPoint = null;
                    this.rectTemp = null;
                    this.rrTemp = null;
                    this.mmTemp = null;

                    this.renderOverlay();
                    this.showOperateMsg('å·²æ¸…é™¤æ‰€æœ‰ç»˜å›¾å…ƒç´ ', true);
                },
                /**
                 * è°ƒæ•´Overlayå¤§å°
                 */
                resizeOverlay() {
                    const el = this.$refs.overlayEl;
                    const wrapper = this.$refs.chartWrapper;
                    if (!el || !wrapper) return;

                    el.setAttribute('width', wrapper.clientWidth);
                    el.setAttribute('height', wrapper.clientHeight);

                    this.renderOverlay();
                },
                /**
                 * æ¸²æŸ“æ‰€æœ‰ç»˜å›¾å…ƒç´ 
                 */
                renderOverlay() {
                    const svg = this.$refs.overlayEl;
                    if (!svg || !this.chart || !this.candleSeries) return;

                    // æ¸…ç©ºç°æœ‰å†…å®¹
                    svg.innerHTML = '';

                    // æ¸²æŸ“è¶‹åŠ¿çº¿
                    this.renderTrendLines(svg);
                    // æ¸²æŸ“çŸ©å½¢
                    this.renderRects(svg);
                    // æ¸²æŸ“ç›ˆäºæ¯”å·¥å…·
                    this.renderRRTools(svg);
                    // æ¸²æŸ“MMå·¥å…·
                    this.renderMMTools(svg);
                    // æ¸²æŸ“ä¸´æ—¶ç»˜åˆ¶çš„å…ƒç´ 
                    this.renderTempElements(svg);
                    // æ¸²æŸ“ K çº¿åºå·ï¼ˆBar Countï¼‰
                    this.renderBarCount(svg);
                },
                renderBarCount(svg) {
                    if (!this.currentKlineData.length) return;

                    const timeScale = this.chart.timeScale();
                    const priceScale = this.candleSeries;
                    const visibleRange = timeScale.getVisibleRange();
                    if (!visibleRange) return;

                    this.currentKlineData.forEach((k, index) => {
                        const barIndex = (index % 81) + 1;

                        // âœ… åªæ˜¾ç¤ºå¶æ•°
                        if (barIndex % 2 !== 0) return;

                        const time = k.openTime / 1000;

                        // âœ… åªç»˜åˆ¶å¯è§†åŒºé—´å†…
                        if (time < visibleRange.from || time > visibleRange.to) return;

                        const x = timeScale.timeToCoordinate(time);
                        const y = priceScale.priceToCoordinate(parseFloat(k.lowPrice));

                        if (x == null || y == null) return;

                        const text = document.createElementNS(
                            'http://www.w3.org/2000/svg',
                            'text'
                        );

                        text.setAttribute('x', x);
                        text.setAttribute('y', y + 16); // ğŸ‘ˆ å¾€ä¸‹åç§»ï¼Œåˆšå¥½åœ¨ K çº¿ä¸‹æ–¹
                        text.setAttribute('fill', '#f59e0b'); // è·Ÿä½ å›¾é‡Œä¸€æ ·çš„æ©™è‰²
                        text.setAttribute('font-size', '11');
                        text.setAttribute('text-anchor', 'middle');
                        text.setAttribute('pointer-events', 'none'); // ä¸å½±å“äº¤äº’
                        text.textContent = (barIndex).toString();

                        svg.appendChild(text);
                    });
                },

                /**
                 * æ¸²æŸ“è¶‹åŠ¿çº¿
                 */
                renderTrendLines(svg) {
                    this.trendLines.forEach(line => {
                        // å¢åŠ ä¸¥æ ¼çš„ç©ºå€¼æ£€æŸ¥
                        if (!line || !line.t1 || !line.t2 || !line.p1 || !line.p2) return;

                        const x1 = this.chart.timeScale().timeToCoordinate(line.t1);
                        const x2 = this.chart.timeScale().timeToCoordinate(line.t2);
                        const y1 = this.candleSeries.priceToCoordinate(line.p1);
                        const y2 = this.candleSeries.priceToCoordinate(line.p2);

                        if (x1 == null || x2 == null || y1 == null || y2 == null) return;

                        const el = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        el.setAttribute('x1', x1);
                        el.setAttribute('y1', y1);
                        el.setAttribute('x2', x2);
                        el.setAttribute('y2', y2);
                        el.setAttribute('stroke', '#2962ff');
                        el.setAttribute('stroke-width', '2');

                        svg.appendChild(el);
                    });
                },
                /**
                 * æ¸²æŸ“çŸ©å½¢
                 */
                renderRects(svg) {
                    this.rects.forEach(rect => {
                        this.drawRect(svg, rect, rect.color, 0.2);
                    });
                },
                /**
                 * æ¸²æŸ“ç›ˆäºæ¯”å·¥å…·ï¼ˆä¼˜åŒ–æ ·å¼å’Œé¢„è§ˆæ•ˆæœï¼‰
                 */
                renderRRTools(svg) {
                    this.rrTools.forEach(rr => {
                        // å¢åŠ ä¸¥æ ¼çš„ç©ºå€¼æ£€æŸ¥
                        if (!rr || !rr.entryTime || !rr.entryPrice || !rr.stopTime || !rr.stopPrice) return;

                        // è®¡ç®—ä»·æ ¼å·®å€¼
                        const priceDiff = Math.abs(rr.entryPrice - rr.stopPrice);
                        const direction = rr.stopPrice > rr.entryPrice ? -1 : 1; // 1=å‘ä¸Šï¼Œ-1=å‘ä¸‹

                        // ç»˜åˆ¶æ­¢æŸåŒºåŸŸï¼ˆçº¢è‰²ï¼‰
                        this.drawRRRect(svg, {
                            t1: rr.entryTime,
                            p1: rr.entryPrice,
                            t2: rr.stopTime,
                            p2: rr.stopPrice
                        }, '#ef4444', 0.1);

                        // ç»˜åˆ¶1å€ç›®æ ‡åŒºåŸŸï¼ˆè“è‰²ï¼‰
                        this.drawRRRect(svg, {
                            t1: rr.entryTime,
                            p1: rr.entryPrice + direction * priceDiff * 1,
                            t2: rr.stopTime,
                            p2: rr.entryPrice
                        }, '#3b82f6', 0.1);

                        // ç»˜åˆ¶2å€ç›®æ ‡åŒºåŸŸï¼ˆç»¿è‰²ï¼‰
                        this.drawRRRect(svg, {
                            t1: rr.entryTime,
                            p1: rr.entryPrice + direction * priceDiff * 2,
                            t2: rr.stopTime,
                            p2: rr.entryPrice + direction * priceDiff * 1
                        }, '#22c55e', 0.1);

                        // ç»˜åˆ¶3å€ç›®æ ‡åŒºåŸŸï¼ˆé»„è‰²ï¼‰
                        this.drawRRRect(svg, {
                            t1: rr.entryTime,
                            p1: rr.entryPrice + direction * priceDiff * 3,
                            t2: rr.stopTime,
                            p2: rr.entryPrice + direction * priceDiff * 2
                        }, '#eab308', 0.1);

                        // ç»˜åˆ¶å…¥åœºçº¿
                        const entryX = this.chart.timeScale().timeToCoordinate(rr.entryTime);
                        const entryY = this.candleSeries.priceToCoordinate(rr.entryPrice);
                        if (entryX != null && entryY != null) {
                            const entryLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            entryLine.setAttribute('x1', entryX - 10);
                            entryLine.setAttribute('y1', entryY);
                            entryLine.setAttribute('x2', entryX + 10);
                            entryLine.setAttribute('y2', entryY);
                            entryLine.setAttribute('stroke', '#ffffff');
                            entryLine.setAttribute('stroke-width', '2');
                            svg.appendChild(entryLine);
                        }
                    });
                },
                renderMMTools(svg) {
                    this.mmTools.forEach(mm => {
                        // å¢åŠ ä¸¥æ ¼çš„ç©ºå€¼æ£€æŸ¥
                        if (!mm || !mm.entryTime || !mm.entryPrice || !mm.stopTime || !mm.stopPrice) return;

                        // è®¡ç®—ä»·æ ¼å·®å€¼
                        const priceDiff = Math.abs(mm.entryPrice - mm.stopPrice);
                        const direction = mm.stopPrice > mm.entryPrice ? -1 : 1; // 1=å‘ä¸Šï¼Œ-1=å‘ä¸‹

                        // ç»˜åˆ¶æ­¢æŸåŒºåŸŸï¼ˆçº¢è‰²ï¼‰
                        this.drawMMRect(svg, {
                            t1: mm.entryTime,
                            p1: mm.entryPrice,
                            t2: mm.stopTime,
                            p2: mm.stopPrice
                        }, '#c6cbf6', 0);

                        // ç»˜åˆ¶1å€ç›®æ ‡åŒºåŸŸï¼ˆè“è‰²ï¼‰
                        this.drawMMRect(svg, {
                            t1: mm.entryTime,
                            p1: mm.entryPrice + direction * priceDiff * 1,
                            t2: mm.stopTime,
                            p2: mm.entryPrice
                        }, '#c6cbf6', 0);

                        // ç»˜åˆ¶2å€ç›®æ ‡åŒºåŸŸï¼ˆç»¿è‰²ï¼‰
                        this.drawMMRect(svg, {
                            t1: mm.entryTime,
                            p1: mm.entryPrice + direction * priceDiff * 2,
                            t2: mm.stopTime,
                            p2: mm.entryPrice + direction * priceDiff * 1
                        }, '#c6cbf6', 0);

                        // ç»˜åˆ¶3å€ç›®æ ‡åŒºåŸŸï¼ˆé»„è‰²ï¼‰
                        this.drawMMRect(svg, {
                            t1: mm.entryTime,
                            p1: mm.entryPrice + direction * priceDiff * 3,
                            t2: mm.stopTime,
                            p2: mm.entryPrice + direction * priceDiff * 2
                        }, '#c6cbf6', 0);
                    });
                },
                /**
                 * æ¸²æŸ“ä¸´æ—¶ç»˜åˆ¶çš„å…ƒç´ ï¼ˆå¢å¼ºç›ˆäºæ¯”é¢„è§ˆæ•ˆæœï¼‰
                 */
                renderTempElements(svg) {
                    // æ¸²æŸ“ä¸´æ—¶è¶‹åŠ¿çº¿
                    if (this.overlayTempPoint && this.activeTool === 'trendline') {
                        // å¢åŠ ç©ºå€¼æ£€æŸ¥
                        if (!this.overlayTempPoint.t || !this.overlayTempPoint.p) return;

                        const time = this.chart.timeScale().coordinateToTime(this.currentMouseX);
                        const price = this.candleSeries.coordinateToPrice(this.currentMouseY);
                        if (!time || price == null) return;

                        const x1 = this.chart.timeScale().timeToCoordinate(this.overlayTempPoint.t);
                        const y1 = this.candleSeries.priceToCoordinate(this.overlayTempPoint.p);
                        const x2 = this.chart.timeScale().timeToCoordinate(time);
                        const y2 = this.candleSeries.priceToCoordinate(price);

                        if (x1 != null && y1 != null && x2 != null && y2 != null) {
                            const el = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            el.setAttribute('x1', x1);
                            el.setAttribute('y1', y1);
                            el.setAttribute('x2', x2);
                            el.setAttribute('y2', y2);
                            el.setAttribute('stroke', '#2962ff');
                            el.setAttribute('stroke-width', '2');
                            el.setAttribute('stroke-dasharray', '5,5');
                            svg.appendChild(el);
                        }
                    }

                    // æ¸²æŸ“ä¸´æ—¶çŸ©å½¢
                    if (this.rectTemp && this.activeTool === 'rect') {
                        this.drawRect(svg, this.rectTemp, this.activeRectColor, 0.1);
                    }

                    // æ¸²æŸ“ä¸´æ—¶ç›ˆäºæ¯”å·¥å…·ï¼ˆå®Œæ•´é¢„è§ˆæ•ˆæœï¼‰
                    if (this.rrTemp && this.activeTool === 'rr') {
                        // å¢åŠ ç©ºå€¼æ£€æŸ¥
                        if (!this.rrTemp || !this.rrTemp.entryTime || !this.rrTemp.entryPrice) return;

                        // è®¡ç®—å½“å‰æ‹–æ‹½çš„æ­¢æŸä»·æ ¼
                        const currentStopPrice = this.rrTemp.stopPrice || this.rrTemp.entryPrice;

                        // åªåœ¨æœ‰ä»·æ ¼å·®æ—¶æ‰æ˜¾ç¤ºç›®æ ‡é¢„è§ˆ
                        if (Math.abs(this.rrTemp.entryPrice - currentStopPrice) > 0) {
                            // è®¡ç®—ä»·æ ¼å·®å€¼
                            const priceDiff = Math.abs(this.rrTemp.entryPrice - currentStopPrice);
                            const direction = currentStopPrice > this.rrTemp.entryPrice ? -1 : 1;

                            // é¢„è§ˆæ­¢æŸåŒºåŸŸï¼ˆçº¢è‰²ï¼Œé€æ˜åº¦é™ä½ï¼‰
                            this.drawRRRect(svg, {
                                t1: this.rrTemp.entryTime,
                                p1: this.rrTemp.entryPrice,
                                t2: this.rrTemp.stopTime || this.rrTemp.entryTime,
                                p2: currentStopPrice
                            }, '#ef4444', 0.2);

                            // é¢„è§ˆ1å€ç›®æ ‡åŒºåŸŸï¼ˆè“è‰²ï¼Œé€æ˜åº¦é™ä½ï¼‰
                            this.drawRRRect(svg, {
                                t1: this.rrTemp.entryTime,
                                p1: this.rrTemp.entryPrice + direction * priceDiff * 1,
                                t2: this.rrTemp.stopTime || this.rrTemp.entryTime,
                                p2: this.rrTemp.entryPrice
                            }, '#3b82f6', 0.15);

                            // é¢„è§ˆ2å€ç›®æ ‡åŒºåŸŸï¼ˆç»¿è‰²ï¼Œé€æ˜åº¦é™ä½ï¼‰
                            this.drawRRRect(svg, {
                                t1: this.rrTemp.entryTime,
                                p1: this.rrTemp.entryPrice + direction * priceDiff * 2,
                                t2: this.rrTemp.stopTime || this.rrTemp.entryTime,
                                p2: this.rrTemp.entryPrice + direction * priceDiff * 1
                            }, '#22c55e', 0.15);

                            // é¢„è§ˆ3å€ç›®æ ‡åŒºåŸŸï¼ˆé»„è‰²ï¼Œé€æ˜åº¦é™ä½ï¼‰
                            this.drawRRRect(svg, {
                                t1: this.rrTemp.entryTime,
                                p1: this.rrTemp.entryPrice + direction * priceDiff * 3,
                                t2: this.rrTemp.stopTime || this.rrTemp.entryTime,
                                p2: this.rrTemp.entryPrice + direction * priceDiff * 2
                            }, '#eab308', 0.15);
                        } else {
                            // åªæ˜¾ç¤ºå…¥åœºç‚¹
                            const entryX = this.chart.timeScale().timeToCoordinate(this.rrTemp.entryTime);
                            const entryY = this.candleSeries.priceToCoordinate(this.rrTemp.entryPrice);
                            if (entryX != null && entryY != null) {
                                const entryLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                entryLine.setAttribute('x1', entryX - 10);
                                entryLine.setAttribute('y1', entryY);
                                entryLine.setAttribute('x2', entryX + 10);
                                entryLine.setAttribute('y2', entryY);
                                entryLine.setAttribute('stroke', '#ffffff');
                                entryLine.setAttribute('stroke-width', '2');
                                entryLine.setAttribute('stroke-dasharray', '3,3');
                                svg.appendChild(entryLine);
                            }
                        }
                    }

                    // æ¸²æŸ“ä¸´æ—¶MMå·¥å…·ï¼ˆå®Œæ•´é¢„è§ˆæ•ˆæœï¼‰
                    if (this.mmTemp && this.activeTool === 'mm') {
                        // å¢åŠ ç©ºå€¼æ£€æŸ¥
                        if (!this.mmTemp || !this.mmTemp.entryTime || !this.mmTemp.entryPrice) return;

                        // è®¡ç®—å½“å‰æ‹–æ‹½çš„æ­¢æŸä»·æ ¼
                        const currentStopPrice = this.mmTemp.stopPrice || this.mmTemp.entryPrice;

                        // åªåœ¨æœ‰ä»·æ ¼å·®æ—¶æ‰æ˜¾ç¤ºç›®æ ‡é¢„è§ˆ
                        if (Math.abs(this.mmTemp.entryPrice - currentStopPrice) > 0) {
                            // è®¡ç®—ä»·æ ¼å·®å€¼
                            const priceDiff = Math.abs(this.mmTemp.entryPrice - currentStopPrice);
                            const direction = currentStopPrice > this.mmTemp.entryPrice ? -1 : 1;

                            // é¢„è§ˆæ­¢æŸåŒºåŸŸï¼ˆçº¢è‰²ï¼Œé€æ˜åº¦é™ä½ï¼‰
                            this.drawMMRect(svg, {
                                t1: this.mmTemp.entryTime,
                                p1: this.mmTemp.entryPrice,
                                t2: this.mmTemp.stopTime || this.mmTemp.entryTime,
                                p2: currentStopPrice
                            }, '#c6cbf6', 0);

                            // é¢„è§ˆ1å€ç›®æ ‡åŒºåŸŸï¼ˆè“è‰²ï¼Œé€æ˜åº¦é™ä½ï¼‰
                            this.drawMMRect(svg, {
                                t1: this.mmTemp.entryTime,
                                p1: this.mmTemp.entryPrice + direction * priceDiff * 1,
                                t2: this.mmTemp.stopTime || this.mmTemp.entryTime,
                                p2: this.mmTemp.entryPrice
                            }, '#c6cbf6', 0);

                            // é¢„è§ˆ2å€ç›®æ ‡åŒºåŸŸï¼ˆç»¿è‰²ï¼Œé€æ˜åº¦é™ä½ï¼‰
                            this.drawMMRect(svg, {
                                t1: this.mmTemp.entryTime,
                                p1: this.mmTemp.entryPrice + direction * priceDiff * 2,
                                t2: this.mmTemp.stopTime || this.mmTemp.entryTime,
                                p2: this.mmTemp.entryPrice + direction * priceDiff * 1
                            }, '#c6cbf6', 0);

                            // é¢„è§ˆ3å€ç›®æ ‡åŒºåŸŸï¼ˆé»„è‰²ï¼Œé€æ˜åº¦é™ä½ï¼‰
                            this.drawMMRect(svg, {
                                t1: this.mmTemp.entryTime,
                                p1: this.mmTemp.entryPrice + direction * priceDiff * 3,
                                t2: this.mmTemp.stopTime || this.mmTemp.entryTime,
                                p2: this.mmTemp.entryPrice + direction * priceDiff * 2
                            }, '#c6cbf6', 0);
                        }
                    }
                },
                /**
                 * ç»˜åˆ¶æ™®é€šçŸ©å½¢
                 */
                drawRect(svg, rect, color, opacity) {
                    // å¢åŠ ä¸¥æ ¼çš„ç©ºå€¼æ£€æŸ¥ï¼Œé˜²æ­¢ä¼ å…¥æ— æ•ˆæ•°æ®
                    if (!svg || !rect || rect.t1 == null || rect.t2 == null || rect.p1 == null || rect.p2 == null) {
                        return;
                    }

                    // å…ˆæ£€æŸ¥æ—¶é—´å€¼æ˜¯å¦æœ‰æ•ˆ
                    let x1, x2, y1, y2;
                    try {
                        x1 = this.chart.timeScale().timeToCoordinate(rect.t1);
                        x2 = this.chart.timeScale().timeToCoordinate(rect.t2);
                        y1 = this.candleSeries.priceToCoordinate(rect.p1);
                        y2 = this.candleSeries.priceToCoordinate(rect.p2);
                    } catch (e) {
                        // æ•è·timeToCoordinateçš„å¼‚å¸¸ï¼Œé˜²æ­¢æ§åˆ¶å°æŠ¥é”™
                        console.debug('ç»˜åˆ¶çŸ©å½¢æ—¶åæ ‡è½¬æ¢å¤±è´¥:', e);
                        return;
                    }

                    // æ£€æŸ¥è½¬æ¢åçš„åæ ‡æ˜¯å¦æœ‰æ•ˆ
                    if (x1 == null || x2 == null || y1 == null || y2 == null) return;

                    // è®¡ç®—çŸ©å½¢çš„å®é™…åæ ‡ï¼ˆç¡®ä¿x1 <= x2ï¼Œy1 <= y2ï¼‰
                    const rx = Math.min(x1, x2);
                    const ry = Math.min(y1, y2);
                    const width = Math.abs(x2 - x1);
                    const height = Math.abs(y2 - y1);

                    // åªç»˜åˆ¶æœ‰å®é™…å¤§å°çš„çŸ©å½¢
                    if (width <= 0 || height <= 0) return;

                    // åˆ›å»ºçŸ©å½¢å…ƒç´ 
                    const rectEl = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rectEl.setAttribute('x', rx);
                    rectEl.setAttribute('y', ry);
                    rectEl.setAttribute('width', width);
                    rectEl.setAttribute('height', height);
                    rectEl.setAttribute('fill', color);
                    rectEl.setAttribute('fill-opacity', opacity);
                    rectEl.setAttribute('stroke', color);
                    rectEl.setAttribute('stroke-width', '1');
                    rectEl.setAttribute('stroke-opacity', '0.8');

                    svg.appendChild(rectEl);
                },
                /**
                 * ç»˜åˆ¶ç›ˆäºæ¯”çŸ©å½¢ï¼ˆè‡ªå®šä¹‰æ ·å¼ï¼šå»æ‰å·¦å³è¾¹æ¡†ï¼Œä¸Šä¸‹è¾¹æ¡†è™šçº¿ï¼‰
                 */
                drawRRRect(svg, rect, color, opacity) {
                    // å¢åŠ ä¸¥æ ¼çš„ç©ºå€¼æ£€æŸ¥ï¼Œé˜²æ­¢ä¼ å…¥æ— æ•ˆæ•°æ®
                    if (!svg || !rect || rect.t1 == null || rect.t2 == null || rect.p1 == null || rect.p2 == null) {
                        return;
                    }

                    // å…ˆæ£€æŸ¥æ—¶é—´å€¼æ˜¯å¦æœ‰æ•ˆ
                    let x1, x2, y1, y2;
                    try {
                        x1 = this.chart.timeScale().timeToCoordinate(rect.t1);
                        x2 = this.chart.timeScale().timeToCoordinate(rect.t2);
                        y1 = this.candleSeries.priceToCoordinate(rect.p1);
                        y2 = this.candleSeries.priceToCoordinate(rect.p2);
                    } catch (e) {
                        // æ•è·timeToCoordinateçš„å¼‚å¸¸ï¼Œé˜²æ­¢æ§åˆ¶å°æŠ¥é”™
                        console.debug('ç»˜åˆ¶ç›ˆäºæ¯”çŸ©å½¢æ—¶åæ ‡è½¬æ¢å¤±è´¥:', e);
                        return;
                    }

                    // æ£€æŸ¥è½¬æ¢åçš„åæ ‡æ˜¯å¦æœ‰æ•ˆ
                    if (x1 == null || x2 == null || y1 == null || y2 == null) return;

                    // è®¡ç®—çŸ©å½¢çš„å®é™…åæ ‡
                    const rx = Math.min(x1, x2);
                    const ry = Math.min(y1, y2);
                    const width = Math.abs(x2 - x1);
                    const height = Math.abs(y2 - y1);

                    // åªç»˜åˆ¶æœ‰å®é™…å¤§å°çš„çŸ©å½¢
                    if (width <= 0 || height <= 0) return;

                    // 1. åˆ›å»ºå¡«å……çŸ©å½¢ï¼ˆæ— æè¾¹ï¼‰
                    const fillRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    fillRect.setAttribute('x', rx);
                    fillRect.setAttribute('y', ry);
                    fillRect.setAttribute('width', width);
                    fillRect.setAttribute('height', height);
                    fillRect.setAttribute('fill', color);
                    fillRect.setAttribute('fill-opacity', opacity);
                    fillRect.setAttribute('stroke', 'none'); // å»æ‰æ‰€æœ‰è¾¹æ¡†
                    svg.appendChild(fillRect);

                    // 2. ç»˜åˆ¶ä¸Šè¾¹æ¡†ï¼ˆè™šçº¿ï¼‰
                    const topLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    topLine.setAttribute('x1', rx);
                    topLine.setAttribute('y1', ry);
                    topLine.setAttribute('x2', rx + width);
                    topLine.setAttribute('y2', ry);
                    topLine.setAttribute('stroke', color);
                    topLine.setAttribute('stroke-width', '1');
                    topLine.setAttribute('stroke-opacity', '0.8');
                    topLine.setAttribute('stroke-dasharray', '4,2'); // è™šçº¿æ ·å¼
                    svg.appendChild(topLine);

                    // 3. ç»˜åˆ¶ä¸‹è¾¹æ¡†ï¼ˆè™šçº¿ï¼‰
                    const bottomLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    bottomLine.setAttribute('x1', rx);
                    bottomLine.setAttribute('y1', ry + height);
                    bottomLine.setAttribute('x2', rx + width);
                    bottomLine.setAttribute('y2', ry + height);
                    bottomLine.setAttribute('stroke', color);
                    bottomLine.setAttribute('stroke-width', '1');
                    bottomLine.setAttribute('stroke-opacity', '0.8');
                    bottomLine.setAttribute('stroke-dasharray', '4,2'); // è™šçº¿æ ·å¼
                    svg.appendChild(bottomLine);

                    // æ³¨æ„ï¼šä¸ç»˜åˆ¶å·¦å³è¾¹æ¡†ï¼Œå®ç°å»æ‰å·¦å³è¾¹æ¡†çš„æ•ˆæœ
                },
                drawMMRect(svg, rect, color, opacity) {
                    // å¢åŠ ä¸¥æ ¼çš„ç©ºå€¼æ£€æŸ¥ï¼Œé˜²æ­¢ä¼ å…¥æ— æ•ˆæ•°æ®
                    if (!svg || !rect || rect.t1 == null || rect.t2 == null || rect.p1 == null || rect.p2 == null) {
                        return;
                    }

                    // å…ˆæ£€æŸ¥æ—¶é—´å€¼æ˜¯å¦æœ‰æ•ˆ
                    let x1, x2, y1, y2;
                    try {
                        x1 = this.chart.timeScale().timeToCoordinate(rect.t1);
                        x2 = this.chart.timeScale().timeToCoordinate(rect.t2);
                        y1 = this.candleSeries.priceToCoordinate(rect.p1);
                        y2 = this.candleSeries.priceToCoordinate(rect.p2);
                    } catch (e) {
                        // æ•è·timeToCoordinateçš„å¼‚å¸¸ï¼Œé˜²æ­¢æ§åˆ¶å°æŠ¥é”™
                        console.debug('ç»˜åˆ¶ç›ˆäºæ¯”çŸ©å½¢æ—¶åæ ‡è½¬æ¢å¤±è´¥:', e);
                        return;
                    }

                    // æ£€æŸ¥è½¬æ¢åçš„åæ ‡æ˜¯å¦æœ‰æ•ˆ
                    if (x1 == null || x2 == null || y1 == null || y2 == null) return;

                    // è®¡ç®—çŸ©å½¢çš„å®é™…åæ ‡
                    const rx = Math.min(x1, x2);
                    const ry = Math.min(y1, y2);
                    const width = Math.abs(x2 - x1);
                    const height = Math.abs(y2 - y1);

                    // åªç»˜åˆ¶æœ‰å®é™…å¤§å°çš„çŸ©å½¢
                    if (width <= 0 || height <= 0) return;

                    // 1. åˆ›å»ºå¡«å……çŸ©å½¢ï¼ˆæ— æè¾¹ï¼‰
                    const fillRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    fillRect.setAttribute('x', rx);
                    fillRect.setAttribute('y', ry);
                    fillRect.setAttribute('width', width);
                    fillRect.setAttribute('height', height);
                    fillRect.setAttribute('fill', color);
                    fillRect.setAttribute('fill-opacity', opacity);
                    fillRect.setAttribute('stroke', 'none'); // å»æ‰æ‰€æœ‰è¾¹æ¡†
                    svg.appendChild(fillRect);

                    // 2. ç»˜åˆ¶ä¸Šè¾¹æ¡†ï¼ˆè™šçº¿ï¼‰
                    const topLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    topLine.setAttribute('x1', rx);
                    topLine.setAttribute('y1', ry);
                    topLine.setAttribute('x2', rx + width);
                    topLine.setAttribute('y2', ry);
                    topLine.setAttribute('stroke', color);
                    topLine.setAttribute('stroke-width', '1');
                    topLine.setAttribute('stroke-opacity', '0.8');
                    svg.appendChild(topLine);

                    // 3. ç»˜åˆ¶ä¸‹è¾¹æ¡†ï¼ˆè™šçº¿ï¼‰
                    const bottomLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    bottomLine.setAttribute('x1', rx);
                    bottomLine.setAttribute('y1', ry + height);
                    bottomLine.setAttribute('x2', rx + width);
                    bottomLine.setAttribute('y2', ry + height);
                    bottomLine.setAttribute('stroke', color);
                    bottomLine.setAttribute('stroke-width', '1');
                    bottomLine.setAttribute('stroke-opacity', '0.8');
                    svg.appendChild(bottomLine);

                    // æ³¨æ„ï¼šä¸ç»˜åˆ¶å·¦å³è¾¹æ¡†ï¼Œå®ç°å»æ‰å·¦å³è¾¹æ¡†çš„æ•ˆæœ
                },
                /**
                 * OverlayæŒ‡é’ˆæŒ‰ä¸‹äº‹ä»¶
                 */
                onOverlayPointerDown(e) {
                    this.currentMouseX = e.offsetX;
                    this.currentMouseY = e.offsetY;

                    if (this.activeTool === 'trendline') {
                        this.handleTrendlineDown(e);
                    } else if (this.activeTool === 'rect') {
                        this.handleRectDown(e);
                    } else if (this.activeTool === 'rr') {
                        this.handleRRDown(e);
                    } else if (this.activeTool === 'mm') {
                        this.handleMMDown(e);
                    }
                },
                /**
                 * OverlayæŒ‡é’ˆç§»åŠ¨äº‹ä»¶
                 */
                onOverlayPointerMove(e) {
                    // è®°å½•å½“å‰é¼ æ ‡ä½ç½®
                    this.currentMouseX = e.offsetX;
                    this.currentMouseY = e.offsetY;

                    if (this.activeTool === 'trendline' && this.overlayTempPoint) {
                        this.renderOverlay();
                    } else if (this.activeTool === 'rect' && this.rectTemp) {
                        const t = this.chart.timeScale().coordinateToTime(e.offsetX);
                        const p = this.candleSeries.coordinateToPrice(e.offsetY);
                        if (!t || p == null) return;
                        this.rectTemp.t2 = t;
                        this.rectTemp.p2 = p;
                        this.renderOverlay();
                    } else if (this.activeTool === 'rr' && this.rrTemp) {
                        // å¢åŠ ç©ºå€¼æ£€æŸ¥
                        if (!this.rrTemp) return;

                        const t = this.chart.timeScale().coordinateToTime(e.offsetX);
                        const p = this.candleSeries.coordinateToPrice(e.offsetY);
                        if (!t || p == null) return;
                        this.rrTemp.stopTime = t;
                        this.rrTemp.stopPrice = p;
                        this.renderOverlay();
                    } else if (this.activeTool === 'mm' && this.mmTemp) {
                        // å¢åŠ ç©ºå€¼æ£€æŸ¥
                        if (!this.mmTemp) return;

                        const t = this.chart.timeScale().coordinateToTime(e.offsetX);
                        const p = this.candleSeries.coordinateToPrice(e.offsetY);
                        if (!t || p == null) return;
                        this.mmTemp.stopTime = t;
                        this.mmTemp.stopPrice = p;
                        this.renderOverlay();
                    }
                },
                /**
                 * OverlayæŒ‡é’ˆæŠ¬èµ·äº‹ä»¶
                 */
                onOverlayPointerUp(e) {
                    if (this.activeTool === 'rect' && this.rectTemp) {
                        // ç¡®ä¿çŸ©å½¢æœ‰å®é™…å¤§å°
                        if (this.rectTemp.t1 !== this.rectTemp.t2 && this.rectTemp.p1 !== this.rectTemp.p2) {
                            this.rectTemp.color = this.activeRectColor;
                            this.rects.push({ ...this.rectTemp });
                        }
                        this.rectTemp = null;
                        this.renderOverlay();
                    } else if (this.activeTool === 'rr' && this.rrTemp) {
                        // å¢åŠ ç©ºå€¼æ£€æŸ¥
                        if (!this.rrTemp || !this.rrTemp.entryTime || !this.rrTemp.entryPrice) {
                            this.rrTemp = null;
                            return;
                        }

                        // ç¡®ä¿ç›ˆäºæ¯”çŸ©å½¢æœ‰å®é™…å¤§å°
                        if (this.rrTemp.entryTime !== this.rrTemp.stopTime &&
                            Math.abs(this.rrTemp.entryPrice - this.rrTemp.stopPrice) > 0) {
                            this.rrTools.push({ ...this.rrTemp });
                            this.showOperateMsg('ç›ˆäºæ¯”å·¥å…·ç»˜åˆ¶å®Œæˆï¼Œå·²è‡ªåŠ¨ç”Ÿæˆ1/2/3å€ç›®æ ‡ä½', true);
                        }
                        this.rrTemp = null;
                        this.renderOverlay();
                    } else if (this.activeTool === 'mm' && this.mmTemp) {
                        // å¢åŠ ç©ºå€¼æ£€æŸ¥
                        if (!this.mmTemp || !this.mmTemp.entryTime || !this.mmTemp.entryPrice) {
                            this.mmTemp = null;
                            return;
                        }

                        // ç¡®ä¿ç›ˆäºæ¯”çŸ©å½¢æœ‰å®é™…å¤§å°
                        if (this.mmTemp.entryTime !== this.mmTemp.stopTime &&
                            Math.abs(this.mmTemp.entryPrice - this.mmTemp.stopPrice) > 0) {
                            this.mmTools.push({ ...this.mmTemp });
                            this.showOperateMsg('ç›ˆäºæ¯”å·¥å…·ç»˜åˆ¶å®Œæˆï¼Œå·²è‡ªåŠ¨ç”Ÿæˆ1/2/3å€ç›®æ ‡ä½', true);
                        }
                        this.mmTemp = null;
                        this.renderOverlay();
                    }
                },
                /**
                 * å¤„ç†è¶‹åŠ¿çº¿æŒ‰ä¸‹äº‹ä»¶
                 */
                handleTrendlineDown(e) {
                    const time = this.chart.timeScale().coordinateToTime(e.offsetX);
                    const price = this.candleSeries.coordinateToPrice(e.offsetY);
                    if (!time || price == null) return;

                    if (!this.overlayTempPoint) {
                        // ç¬¬ä¸€ä¸ªç‚¹
                        this.overlayTempPoint = { t: time, p: price };
                    } else {
                        // ç¬¬äºŒä¸ªç‚¹ï¼Œå®Œæˆè¶‹åŠ¿çº¿ç»˜åˆ¶
                        this.trendLines.push({
                            t1: this.overlayTempPoint.t,
                            p1: this.overlayTempPoint.p,
                            t2: time,
                            p2: price
                        });
                        this.overlayTempPoint = null;
                        this.renderOverlay();
                    }
                },
                /**
                 * å¤„ç†çŸ©å½¢æŒ‰ä¸‹äº‹ä»¶
                 */
                handleRectDown(e) {
                    const t = this.chart.timeScale().coordinateToTime(e.offsetX);
                    const p = this.candleSeries.coordinateToPrice(e.offsetY);
                    if (!t || p == null) return;
                    this.rectTemp = { t1: t, p1: p, t2: t, p2: p };
                },
                /**
                 * å¤„ç†ç›ˆäºæ¯”æŒ‰ä¸‹äº‹ä»¶
                 */
                handleRRDown(e) {
                    const t = this.chart.timeScale().coordinateToTime(e.offsetX);
                    const p = this.candleSeries.coordinateToPrice(e.offsetY);
                    if (!t || p == null) return;

                    // åˆå§‹åŒ–ç›ˆäºæ¯”ä¸´æ—¶æ•°æ®ï¼ˆå…¥åœºç‚¹ï¼‰
                    this.rrTemp = {
                        entryTime: t,
                        entryPrice: p,
                        stopTime: t,
                        stopPrice: p
                    };
                    this.showOperateMsg('å·²è®¾ç½®å…¥åœºç‚¹ï¼Œè¯·æ‹–æ‹½è‡³æ­¢æŸä½', true);
                },
                handleMMDown(e) {
                    const t = this.chart.timeScale().coordinateToTime(e.offsetX);
                    const p = this.candleSeries.coordinateToPrice(e.offsetY);
                    if (!t || p == null) return;

                    // åˆå§‹åŒ–MMä¸´æ—¶æ•°æ®ï¼ˆå…¥åœºç‚¹ï¼‰
                    this.mmTemp = {
                        entryTime: t,
                        entryPrice: p,
                        stopTime: t,
                        stopPrice: p
                    };
                },
                /**
                 * åˆå§‹åŒ–åå­—å…‰æ ‡ç›‘å¬ï¼ˆæ‚¬æµ®æç¤ºï¼‰
                 */
                initCrosshairListener() {
                    if (!this.chart || !this.candleSeries) return;

                    this.chart.subscribeCrosshairMove((param) => {
                        const point = param.point;
                        if (!point || !param.time) {
                            this.currentKline = null;
                            this.tooltipPos.opacity = 0;
                            return;
                        }
                        // åŒ¹é…å½“å‰Kçº¿æ•°æ®
                        const currentKline = this.currentKlineData.find(k => k["openTime"] === param.time * 1000);
                        if (!currentKline) {
                            this.currentKline = null;
                            this.tooltipPos.opacity = 0;
                            return;
                        }
                        this.currentKline = currentKline;

                        // è®¡ç®—æç¤ºæ¡†ä½ç½®ï¼ˆè¾¹ç•Œå¤„ç†ï¼‰
                        const chartRect = this.$refs.chartEl.getBoundingClientRect();
                        const tooltipEl = this.$refs.tooltipEl;
                        const tooltipWidth = tooltipEl.offsetWidth || 180;
                        const tooltipHeight = tooltipEl.offsetHeight || 100;

                        let left = point.x + 10;
                        let top = point.y + 5;

                        const maxLeft = chartRect.width - tooltipWidth - 10;
                        const maxTop = chartRect.height - tooltipHeight - 10;
                        left = Math.min(left, maxLeft);
                        left = Math.max(left, 10);
                        top = Math.min(top, maxTop);
                        top = Math.max(top, 10);

                        // æ›´æ–°æç¤ºæ¡†ä½ç½®
                        this.tooltipPos = {
                            top: top,
                            left: left,
                            opacity: 1
                        };
                    });

                    // æ–°å¢ï¼šç›‘å¬å›¾è¡¨ç‚¹å‡»äº‹ä»¶ï¼ˆä»…åœ¨cursoræ¨¡å¼ä¸‹ç”Ÿæ•ˆï¼‰
                    this.chart.subscribeClick((param) => {
                        if (this.activeTool === 'cursor' && param.point) {
                            // å°†ç‚¹å‡»ä½ç½®çš„ä»·æ ¼å¡«å……åˆ°è¾“å…¥æ¡†
                            const price = this.candleSeries.coordinateToPrice(param.point.y);
                            if (price) {
                                this.newPriceLine.price = price.toFixed(1); // ä¿ç•™1ä½å°æ•°
                                if (!this.isSim) {
                                    this.simEntryPrice = price.toFixed(1); // ä¿ç•™1ä½å°æ•°
                                }
                            }
                        }
                    });
                },

                /**
                 * åŠ è½½æŒ‡å®šæ—¥æœŸèŒƒå›´çš„Kçº¿æ•°æ®
                 */
                async loadKlineByDateRange(targetTime, direction) {
                    this.isLoading = true;
                    this.operateMsg = '';
                    try {
                        // ç§»åŠ¨å¼€å§‹æ—¶é—´
                        if (targetTime === -1) {
                            if (this.interval === '5m') {
                                this.startTime = new Date(new Date(Date.parse(this.startTime) + direction * 5 * 60 * 1000).getTime() - new Date().getTimezoneOffset() * 60 * 1000).toISOString().slice(0, 16);
                            } else if (this.interval === '1h') {
                                this.startTime = new Date(new Date(Date.parse(this.startTime) + direction * 60 * 60 * 1000).getTime() - new Date().getTimezoneOffset() * 60 * 1000).toISOString().slice(0, 16);
                            }
                        }
                        // ç§»åŠ¨ç»“æŸæ—¶é—´
                        else if (targetTime === 1) {
                            if (this.interval === '5m') {
                                this.endTime = new Date(new Date(Date.parse(this.endTime) + direction * 5 * 60 * 1000).getTime() - new Date().getTimezoneOffset() * 60 * 1000).toISOString().slice(0, 16);
                            } else if (this.interval === '1h') {
                                this.endTime = new Date(new Date(Date.parse(this.endTime) + direction * 60 * 60 * 1000).getTime() - new Date().getTimezoneOffset() * 60 * 1000).toISOString().slice(0, 16);
                            }
                        }

                        // è°ƒç”¨åå°æ¥å£
                        const response = await fetch(`${this.apiBaseUrl}/c/binance/kline_range?s=${this.symbol}&i=${this.interval}&start=${this.startTime}&end=${this.endTime}&force=false&location=${this.location}`, {
                            method: 'GET',
                            headers: {
                                'Content-Type': 'application/json',
                                'Accept': 'application/json',
                            },
                        });

                        if (!response.ok) {
                            const errorText = await response.text();
                            throw new Error(errorText || `è¯·æ±‚å¤±è´¥ï¼š${response.status}`);
                        }

                        const result = await response.json();
                        this.currentKlineData = result.data || [];
                        this.currentStep = this.targetStep;

                        // è½¬æ¢æ•°æ®æ ¼å¼å¹¶æ¸²æŸ“å›¾è¡¨
                        const chartData = this.currentKlineData.map(item => ({
                            time: Math.floor(item["openTime"] / 1000), // è½¬æ¢ä¸ºç§’çº§æ—¶é—´æˆ³
                            open: parseFloat(item["openPrice"]),
                            high: parseFloat(item["highPrice"]),
                            low: parseFloat(item["lowPrice"]),
                            close: parseFloat(item["closePrice"])
                        }));
                        this.candleSeries.setData(chartData);
                        const ema20Data = this.calculateEMA(chartData, 20);
                        this.ema20Series.setData(ema20Data);
                        this.chart.timeScale().fitContent();

                        this.showOperateMsg(`æˆåŠŸåŠ è½½${this.targetStep}æ ¹Kçº¿`, true);
                    } catch (error) {
                        console.error('åŠ è½½Kçº¿å¤±è´¥ï¼š', error);
                        this.showOperateMsg(`åŠ è½½å¤±è´¥ï¼š${error.message}`, false);
                    } finally {
                        this.isLoading = false;
                    }
                },

                async reDownloadKlineByDateRange() {
                    this.isLoading = true;
                    this.operateMsg = '';
                    try {
                        // è°ƒç”¨åå°æ¥å£
                        const response = await fetch(`${this.apiBaseUrl}/c/binance/kline_range?s=${this.symbol}&i=${this.interval}&start=${this.startTime}&end=${this.endTime}&force=true&location=${this.location}`, {
                            method: 'GET',
                            headers: {
                                'Content-Type': 'application/json',
                                'Accept': 'application/json',
                            },
                        });

                        if (!response.ok) {
                            const errorText = await response.text();
                            throw new Error(errorText || `è¯·æ±‚å¤±è´¥ï¼š${response.status}`);
                        }

                        const result = await response.json();
                        this.currentKlineData = result.data || [];
                        this.currentStep = this.targetStep;

                        // è½¬æ¢æ•°æ®æ ¼å¼å¹¶æ¸²æŸ“å›¾è¡¨
                        const chartData = this.currentKlineData.map(item => ({
                            time: Math.floor(item["openTime"] / 1000), // è½¬æ¢ä¸ºç§’çº§æ—¶é—´æˆ³
                            open: parseFloat(item["openPrice"]),
                            high: parseFloat(item["highPrice"]),
                            low: parseFloat(item["lowPrice"]),
                            close: parseFloat(item["closePrice"])
                        }));
                        this.candleSeries.setData(chartData);
                        const ema20Data = this.calculateEMA(chartData, 20);
                        this.ema20Series.setData(ema20Data);
                        this.chart.timeScale().fitContent();

                        this.showOperateMsg(`æˆåŠŸåŠ è½½${this.targetStep}æ ¹Kçº¿`, true);
                    } catch (error) {
                        console.error('åŠ è½½Kçº¿å¤±è´¥ï¼š', error);
                        this.showOperateMsg(`åŠ è½½å¤±è´¥ï¼š${error.message}`, false);
                    } finally {
                        this.isLoading = false;
                    }
                },

                /**
                 * é‡ç½®å›æ”¾
                 */
                resetPlayback() {
                    this.currentStep = 0;
                    this.targetStep = 1;
                    this.currentKlineData = [];
                    this.operateMsg = '';
                    this.candleSeries.setData([]);
                    this.ema20Series.setData([]);
                    this.currentKline = null;
                    this.tooltipPos.opacity = 0;
                    // æ¸…ç©ºæ‰€æœ‰ç»˜å›¾å…ƒç´ 
                    this.trendLines = [];
                    this.rects = [];
                    this.rrTools = [];
                    this.overlayTempPoint = null;
                    this.rectTemp = null;
                    this.rrTemp = null;
                    this.renderOverlay();
                },

                /**
                 * æ˜¾ç¤ºæ“ä½œæç¤ºä¿¡æ¯
                 */
                showOperateMsg(msg, isSuccess) {
                    this.operateMsg = msg;
                    this.operateSuccess = isSuccess;
                    // 5ç§’åè‡ªåŠ¨æ¸…é™¤æç¤º
                    setTimeout(() => {
                        this.operateMsg = '';
                    }, 5000);
                },

                /**
                 * æ ¼å¼åŒ–æ—¶é—´æˆ³
                 */
                formatTimestamp(timestamp) {
                    if (!timestamp) return '';
                    // å…¼å®¹æ¯«ç§’/ç§’çº§æ—¶é—´æˆ³
                    const date = new Date(timestamp.toString().length > 10 ? timestamp : (timestamp * 1000));
                    return new Intl.DateTimeFormat('zh-CN', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    }).format(date);
                },

                /**
                 * å¤„ç†çª—å£å¤§å°å˜åŒ–
                 */
                handleWindowResize() {
                    if (!this.chart || !this.$refs.chartEl) return;
                    this.chart.applyOptions({ height: this.$refs.chartEl.clientHeight });
                    if (this.currentKlineData.length > 0) this.chart.timeScale().fitContent();
                }
            }
        }).mount('#app');
    </script>
</body>

</html>